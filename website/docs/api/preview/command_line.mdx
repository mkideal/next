---
pagination_prev: null
pagination_next: null
---
# CommandLine {#user-content-CommandLine}
## Command {#user-content-CommandLine_Command}
### build {#user-content-CommandLine_Command_build}

`build` command builds a next project file or runs all next project files in a directory. It reads the project file and compiles the source files according to the project configuration. The project file is a YAML or JSON file that contains the project [Configuration](#user-content-CommandLine_Configuration).

Example:

```sh
# build all .nextproj files in the current directory
next build

# build the example.nextproj file
next build example.nextproj

# build all .nextproj files in the example directory
next build example/

# build multiple project files or directories
next build example1.nextproj example2.nextproj example
```

:::tip
**.nextproj** is recommended for the Next project file.
:::

### grammar {#user-content-CommandLine_Command_grammar}

`grammar` command generates the default grammar for the next files.

Example:

```sh
next grammar # generate the default grammar to the standard output with YAML format
next grammar grammar.yaml # generate the default grammar with YAML format
next grammar grammar.yml # generate the default grammar with YAML format
next grammar grammar.json # generate the default grammar with JSON format
```

:::note
The default grammar is generated in YAML format if the file extension is not provided.
Currently, the supported file extensions are `.json`, `.yaml`, and `.yml` (alias of `.yaml`).
:::

### version {#user-content-CommandLine_Command_version}

`version` command prints the version of the next compiler. It prints the version of the next compiler and exits the program.

Example:

```sh
next version
```

Output:

```
next v0.0.4(main: 51864a35de7890d63bfd8acecdb62d20372ca963) built at 2024/09/27T22:58:21+0800 by go1.23.0
```

## Configuration {#user-content-CommandLine_Configuration}

import CodeBlock from "@theme/CodeBlock";
import ExampleNextProjSource from "!!raw-loader!@site/example/example.nextproj";

Configuration represents the configuration of the Next project. The configuration is used to mamange the compiler options, such as verbosity, output directories, and custom templates. If the configuration is provided, you can generate code like this:

```sh
next build example.nextproj
```

The configuration file is a YAML or JSON (for .json extension) file that contains the compiler options. Here is an example of the configuration file:

<CodeBlock language="yaml" title="example.nextproj">
	{ExampleNextProjSource}
</CodeBlock>

###### .env {#user-content-CommandLine_Configuration__env}
<div className="property-container">

`.env` represents the custom environment variables for code generation.

Example:

```yaml
env:
  VERSION: "2.1"
  DEBUG: ""
  NAME: myapp
```

See the [-D](#user-content-CommandLine_Flag_-D) flag for more information.

</div>

###### .grammar {#user-content-CommandLine_Configuration__grammar}
<div className="property-container">

`.grammar` represents the custom grammar for the next source code.

Example:

```yaml
grammar: grammar.yaml
```

See the [-g](#user-content-CommandLine_Flag_-g) flag for more information.

</div>

###### .head {#user-content-CommandLine_Configuration__head}
<div className="property-container">

`.head` represents the header comment for generated code.

Example:

```yaml
head: "Code generated by Next; DO NOT EDIT."
```

See the [-head](#user-content-CommandLine_Flag_-head) flag for more information.

</div>

###### .mapping {#user-content-CommandLine_Configuration__mapping}
<div className="property-container">

`.mapping` represents the language-specific type mappings and features.

Example:

```yaml
mapping:
  cpp.vector: "std::vector<%T%>"
  java.array: "ArrayList<%T%>"
  go.map: "map[%K%]%V%"
  python.ext: ".py"
  protobuf.vector: "repeated %T.E%"
  ruby.comment: "# %T%"
```

See the [-M](#user-content-CommandLine_Flag_-M) flag for more information.

</div>

###### .output {#user-content-CommandLine_Configuration__output}
<div className="property-container">

`.output` represents the output directories for generated code of each target language.

Example:

```yaml
output:
  go: ./output/go
  ts: ./output/ts
```

See the [-O](#user-content-CommandLine_Flag_-O) flag for more information.

</div>

###### .solvers {#user-content-CommandLine_Configuration__solvers}
<div className="property-container">

`.solvers` represents the custom annotation solver programs for code generation.

Example:

```yaml
solvers:
  message: "message-type-allocator message-types.json"
```

See the [-X](#user-content-CommandLine_Flag_-X) flag for more information.

</div>

###### .sources {#user-content-CommandLine_Configuration__sources}
<div className="property-container">

`.sources` represents the source directories or files.

Example:

```yaml
sources:
  - demo.next
  - src/next/
```

</div>

###### .strict {#user-content-CommandLine_Configuration__strict}
<div className="property-container">

`.strict` represents the strict mode of the compiler.

Example:

```yaml
strict: true
```

See the [-s](#user-content-CommandLine_Flag_-s) flag for more information.

</div>

###### .templates {#user-content-CommandLine_Configuration__templates}
<div className="property-container">

`.templates` represents the custom template directories or files for each target language.

Example:

```yaml
templates:
  go:
    - ./templates/go
    - ./templates/go_extra.npl
  python:
    - ./templates/python.npl
```

See the [-T](#user-content-CommandLine_Flag_-T) flag for more information.

</div>

###### .verbose {#user-content-CommandLine_Configuration__verbose}
<div className="property-container">

`.verbose` represents the verbosity level of the compiler.

Example:

```yaml
verbose: 1
```

See the [-v](#user-content-CommandLine_Flag_-v) flag for more information.

</div>

## Flag {#user-content-CommandLine_Flag}
### -D {#user-content-CommandLine_Flag_-D}

`-D` represents the custom environment variables for code generation. The value is a map of environment variable names and their optional values.

Example:

```sh
next -D VERSION=2.1 -D DEBUG -D NAME=myapp ...
```

```npl
{{env.NAME}}
{{env.VERSION}}
```

Output:

```
myapp
2.1
```

### -M {#user-content-CommandLine_Flag_-M}

`-M` represents the language-specific type mappings and features. **%T%**, **%T.E%**, **%N%**, **%K%**, **%V%** are placeholders replaced with actual types or values. **%T.E%** is the final element type of a vector or array. It's used to get the element type of multi-dimensional arrays.

Example:

```sh
next -M cpp.vector="std::vector<%T%>" \
     -M java.array="ArrayList<%T%>" \
     -M go.map="map[%K%]%V%" \
     -M python.ext=.py \
     -M protobuf.vector="repeated %T.E%" \
     -M ruby.comment="# %T%" \
     ...
```

### -O {#user-content-CommandLine_Flag_-O}

`-O` represents the output directories for generated code of each target language.

Example:

```sh
next -O go=./output/go -O ts=./output/ts ...
```

:::tip

The `{{meta.path}}` is relative to the output directory.

:::

### -T {#user-content-CommandLine_Flag_-T}

`-T` represents the custom template directories or files for each target language. You can specify multiple templates for a single language.

Example:

```sh
next -T go=./templates/go \
     -T go=./templates/go_extra.npl \
     -T python=./templates/python.npl \
     ...
```

### -X {#user-content-CommandLine_Flag_-X}

`-X` represents the custom annotation solver programs for code generation. Annotation solvers are executed in a separate process to solve annotations. All annotations are passed to the solver program via stdin and stdout. The built-in annotation `next` is reserved for the Next compiler.

Example:

```sh
next -X message="message-type-allocator message-types.json" ...
```

:::tip

In the example above, the `message-type-allocator` is a custom annotation solver program that reads the message types from the `message-types.json` file and rewrite the message types to the `message-types.json` file.

:::

### -g {#user-content-CommandLine_Flag_-g}

`-g` represents the custom grammar for the next source code.

Example:

```sh
next -g grammar.yaml ...
```

:::note
By default, the compiler uses the built-in grammar for the next source code.
You can set a custom grammar file to define a subset of the next grammar.
The grammar file is a JSON file that contains rules.

If `-s` is not set, the compiler will ignore unknown annotations and unknown annotation parameters.
:::

### -head {#user-content-CommandLine_Flag_-head}

`-head` represents the header comment for generated code. The value is a string that represents the header comment for generated code. The default value is an empty string, which means default header comment is used.

Example:

```sh
next -head "Code generated by Next; DO NOT EDIT." ...
```

:::note

Do not add the comment characters like `//` or `/* */` in the header. Next will add them automatically based on the target language comment style.

:::

### -s {#user-content-CommandLine_Flag_-s}

`-s` represents the strict mode of the compiler. The default value is **false**, which means the compiler is not in strict mode. The value **true** enables the strict mode, which is used for strict validation of the next source code, such as unknown annotations and unknown annotation parameters.

Example:

```sh
next -s ...
```

### -t {#user-content-CommandLine_Flag_-t}

`-t` represents the test mode of the compiler. The default value is **false**, which means the compiler is not in test mode. The value **true** enables the test mode, which is used for validating but not generating code.

Example:

```sh
next -t ...
```

### -v {#user-content-CommandLine_Flag_-v}

`-v` represents the verbosity level of the compiler. The default value is **0**, which only shows error messages. The value **1** shows debug messages, and **2** shows trace messages. Usually, the trace message is used for debugging the compiler itself. Levels **1** (debug) and above enable execution of:

- **print** and **printf** in Next source files (.next).
- **debug** in Next template files (.npl).

Example:

```sh
next -v 1 ...
```

